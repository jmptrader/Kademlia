<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Implementing the Kademlia P2P DH</title>
</head>

<body>

<p>Implementing the Kademlia Peer-to-Peer Distributed Hash Table</p>
<p>A journey from specification to implementation (with some help along the 
way.)</p>
<h2>Introduction</h2>
<p>There's quite a few implementations of the Kademlia peer-to-peer (P2P) 
distributed hash table (DHT) algorithm out there on GitHub.&nbsp; My perusal of 
the implementations (mainly focusing on C#, but some Python and Go projects as 
well) on <a href="https://github.com/search?utf8=&#10003;&q=kademlia&type=">GitHub</a> 
vary from incomplete to WTF?&nbsp; All the implementation pretty much suffer 
from:</p>
<ol>
	<li>Lack of documentation: by this I mean matching code to the 
	specifications in the original document.&nbsp; Strange code behaviors are 
	not discussed.</li>
	<li>Entanglement: several implementations are entangled with &quot;applications&quot;, 
	such as P2P music streaming and vote tallying</li>
	<li>Lack of abstraction: pretty much every implementation I've seen does not 
	abstract out the communication protocol, whether UPD, TCP, or in-memory, 
	which is particularly useful for testing.</li>
	<li>Overly complex: some implementations incorporate asynchronous handling 
	of messages and other behaviors that are best abstracted out of the core 
	implementation.</li>
</ol>
<p>The best C# implementation that I've found is
<a href="https://github.com/zencoders/sambatyon/blob/master/Kademlia/Kademlia/BucketList.cs">
zencoders sambatyon repo</a> on GitHub.&nbsp; As far as I can tell, the only 
significant issue with this implementation is the lack of abtraction -- it's 
quite entangled with a file-based data store, a UDP communication protocol, and 
additional but unnecessary information in the store &quot;value&quot; because it's 
intended to be a peer-to-peer audio player.&nbsp; That said, I reference this 
implementation wherever I have taken implementation or obtained ideas.</p>
<p>As an aside, I'd have to say this about open source projects:</p>
<ol>
	<li>One person open source projects are great when they implement something 
	simple and compartmentalized.</li>
	<li>More complex open source solutions work best when there's a team of 
	people to review everything from architecture to stupid spelling mistakes to 
	writing and maintaining decent tests and documentation.</li>
</ol>
<p>Having many open source projects on GitHub, most of which fail to provide the 
benefits of a team mentioned in point #2, I actually consider myself to be 
contributing to the problem, not the solution.</p>
<h3>What is Kademlia?</h3>
<p>From Wikipedia:</p>
<p><i>Kademlia is a distributed hash table for decentralized peer-to-peer 
computer networks designed by Petar Maymounkov and David Mazières in 2002. It 
specifies the structure of the network and the exchange of information through 
node lookups. Kademlia nodes communicate among themselves using UDP. A virtual 
or overlay network is formed by the participant nodes. Each node is identified 
by a number or node ID. The node ID serves not only as identification, but the 
Kademlia algorithm uses the node ID to locate values (usually file hashes or 
keywords). In fact, the node ID provides a direct map to file hashes and that 
node stores information on where to obtain the file or resource.</i></p>
<h3>Who Uses Kademlia?</h3>
<p>Kademlia is used in file sharing networks.&nbsp; For example,
<a href="https://en.wikipedia.org/wiki/BitTorrent">BitTorrent</a> uses a DHT 
based on an implementation of the Kademlia algorithm.&nbsp;
<a href="https://en.wikipedia.org/wiki/Kad_network">Kad network</a> uses the 
Kademlia protocol, with <a href="https://en.wikipedia.org/wiki/EMule">eMule</a> 
being an open source Windows client.</p>
<h3>The Kademlia Specification</h3>
<p>The original specification can be found
<a href="https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf">
here</a>.&nbsp; We'll reference this spec frequently as the code is developed.&nbsp; 
A decent slide deck with some nice pictures is
<a href="https://tams.informatik.uni-hamburg.de/lehre/2004ss/vorlesung/medientechnik/material/kpres.pdf">
here</a>.&nbsp; Lastly, an excellent specification for Kademlia can be found
<a href="http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html">
here</a>.</p>
<h3>But Why?</h3>
<p>I've become interested in peer-to-peer networks as a result of my &quot;fly on the 
wall&quot; involvement with <a href="https://holochain.org/">Holochain</a> (from the 
same people that were co-authors of the
<a href="https://www.codeproject.com/Articles/894188/Introducing-Semtrex">
Semtrex</a> article) and the underlying technologies of blockchains like Bitcoin 
and Ethereum.&nbsp; I've already written about some of the core technology 
components, such as
<a href="https://www.codeproject.com/Articles/1176140/Understanding-Merkle-Trees-Why-use-them-who-uses-t">
Merkle Trees</a> and a
<a href="https://www.codeproject.com/Articles/1172340/Hashcash-or-Proof-of-Work">
Proof of Work</a> algorithm, and a deep understanding of a respected P2P DHT 
algorithm seems like the next logical step in understanding the whole gestalt of 
blockchains.&nbsp; </p>
<p>I also am a firm believer that:</p>
<ol>
	<li><a href="https://en.wikipedia.org/wiki/List_of_cryptocurrencies">As 
	wikipedia puts it</a> &quot;New cryptocurrency can be created any time.&quot;&nbsp; 
	These things are here and are not going to go away.&nbsp; It's chaos right 
	now, there's lots of questions and problems, but
	<a href="http://www.businessinsider.com/bitcoin-price-security-equity-sec-2017-7">
	even the SEC is looking at how to regulate cryptocurrencies</a>, and I 
	suspect the IRS is trying to figure out how to tax these things.</li>
	<li>The underlying technology to not just cryptocurrency but any blockchain 
	that implement <a href="https://en.wikipedia.org/wiki/Smart_contract">smart 
	contracts</a> essentially must include a peer-to-peer distributed hash 
	table, at least with regards to how blockchain technology is being discussed 
	and applied (using a blockchain in a centralized scenario is sort of 
	pointless except perhaps for logging purposes.)&nbsp; Understanding how this 
	works is important.</li>
	<li>Centralized data, except for performance reasons, is
	<a href="http://sandhill.com/article/is-data-decentralization-the-new-trend/">
	on its way out</a>.&nbsp; As that last link states: &quot;The more the data 
	management industry consolidates, the more opposing forces decentralize the 
	market.&quot;&nbsp; And peer-to-peer decentralizing has built in redundancy 
	protecting from single-point data loss and access failures.&nbsp; Not that 
	decentralizing has its own problems -- security will probably be the main 
	one, if it isn't already.&nbsp; As an aside, read this short paper on
	<a href="https://arxiv.org/pdf/1506.03471.pdf">Enigma</a>.</li>
</ol>
<p>So while this is a personal venture, it is also a recognition that there are 
some interesting and complicated technologies coming down the road that need to 
be properly understood, and protocols like Kademlia are a good starting point 
for looking at a P2P DHT implementation.&nbsp; As to why Kademlia specifically, 
the summary to the spec says it best:</p>
<p><i>&quot;With its novel XOR-based metric topology, Kademlia is the first 
peer-to-peer system to combine provable consistency and performance, 
latency-minimizing routing, and a symmetric, unidirectional topology. Kademlia 
furthermore introduces a concurrency parameter, a, that lets people trade a 
constant factor in bandwidth for asynchronous lowest-latency hop selection and 
delay-free fault recovery. Finally, Kademlia is the first peer-to-peer system to 
exploit the fact that node failures are inversely related to uptime.&quot;</i></p>
<h3>Where did the Name Come From?</h3>
<p>As <a href="http://www.maymounkov.org/kademlia">Petar Maymounkov</a>, one of 
the co-creators of Kademlia says: &quot;it is a Turkish word for a “lucky man” and, 
more importantly, is the name of a mountain peak in Bulgaria.&quot;&nbsp; OK then.</p>
<h3>Protocol Before Implementation</h3>
<p>And as Petar stated (same link as above): &quot;The good or bad news (depending on 
how you look at it) is that Kademlia was baked as a protocol and algorithm 
before it ever was implemented.&quot;&nbsp; Fascinating.&nbsp; I just would not have 
the confidence to do that!</p>
<h2>High Level Architecture</h2>
<p>In this document, <font color="#FF00FF">fuchsia text</font> is used when 
quoting from the Kademlia specification.</p>
<p>There are four components to the high level architecture necessary to 
implement the Kademlia protocol:</p>
<ol>
	<li>Node: The concept of a node.&nbsp; Each node has a private 160-bit ID (a 
	SHA-1 hash).&nbsp; <font color="#FF00FF">Keys are opaque, 160-bit quantities 
	(e.g., the SHA-1 hash of some larger data). Participating computers each 
	have a node ID in the 160-bit key space. </font>(From the Introduction)</li>
	<li>Storage: Each node stores key-value pairs, where the key is also a 
	160-bit SHA-1 hash.&nbsp;&nbsp; <font color="#FF00FF">(key,value) pairs are 
	stored on nodes with IDs “close” to the key for some notion of closeness.</font>&nbsp; 
	The storage mechanism, whether in-memory, key-value database, file system, 
	or other, is not specified and is a good point for abstraction. (From the 
	Introduction)</li>
	<li>Routing: Nearby servers for a given key are located with an efficient 
	routing algorithm.&nbsp; <font color="#FF00FF">A node- ID-based routing 
	algorithm lets anyone efficiently locate servers near any given target key. </font>
	(From the Introduction)</li>
	<li>Communication protocol: a means of communicating between nodes (usually 
	separate computers) must exist.&nbsp; The original Kademlia specification 
	states that <font color="#FF00FF">every node keeps a list of (IP address, 
	UDP port, Node ID)</font> of nearby nodes.&nbsp; As with storage, this is a 
	good place for abstraction so that different protocols can be easily 
	employed. (Section 2.2 of the spec)</li>
</ol>
<p>This is expressed in the following diagram:</p>
<p><img border="0" src="highlevel.png" width="625" height="271"></p>
<h3>Wireframe Implementation</h3>
<p>From the above, we can put together a wireframe implementation.&nbsp; The 
abstractions are implemented as interfaces:</p>
<pre>public interface IRouter { }
public interface IAddress { }

public interface IStorage
{
  string Get(string key);
  string Set(string key, string val);
}</pre>
<p>and the concrete class is a stub:</p>
<pre>public class Router
{
}</pre>
<p>The <code>Node</code> class has a minimal implementation for initializing an ID (explained 
next):</p>
<pre>public class Node
{
  public ID NodeID { get; }

  public Node()
  {
    NodeID = ID.RandomID();
  }

  public Node(ID id)
  {
    NodeID = id;
  }

  public Node(byte[] id)
  {
    NodeID = new ID(id);
  }
}</pre>
<p>and there's a simple in-memory storage wrapping a <code>Dictionary</code>:</p>
<pre>/// &lt;summary&gt;
/// Implements in-memory storage for key-value pairs.
/// &lt;/summary&gt;
public class InMemoryStorage : IStorage
{
  protected Dictionary&lt;string, string&gt; storage;

  public InMemoryStorage()
  {
    storage = new Dictionary&lt;string, string&gt;();
  }

  public string Get(string key)
  {
    return storage[key];
  }

  public void Set(string key, string val)
  {
    storage[key] = val;
  }
}</pre>
<h3>The ID Class (Section 2.1)</h3>
<p>This class is heavily borrowed from zencoders peer-to-peer music player, the 
original source can be found
<a href="https://github.com/zencoders/sambatyon/blob/master/Kademlia/Kademlia/ID.cs">
here</a>.&nbsp; I stripped out a variety of things, but the core implementation 
remains: </p>
<p><img border="0" src="id.png" width="231" height="394"></p>
<p>Why do we need this?&nbsp; Well, as the specification states:</p>
<p><font color="#FF00FF">Many of Kademlia’s benefits result from its use of a 
novel XOR metric for distance between points in the key space. XOR is symmetric, 
allowing Kademlia participants to receive lookup queries from precisely the same 
distribution of nodes contained in their routing tables...Kademlia effectively 
treats nodes as leaves in a binary tree, with each node’s position determined by 
the shortest unique prefix of its ID...</font><span style="font-size: 12.0pt; font-family: 'Times New Roman',serif; color: #FF00FF">The 
Kademlia protocol ensures that every node knows of at least one node in each of 
its subtrees, if that subtree contains a node. With this guarantee, any node can 
locate any other node by its ID. </span></p>
<p>The ID class implements the distance computations and other algorithmic 
pieces necessary to manage the 160-bit ID, which is at the heart of Kademlia's 
routing algorithm.&nbsp; Portions of this implementation are discussed next.</p>
<h2>The Concept of Closeness (Section 2.1)</h2>
<p><font color="#FF00FF">Each Kademlia node has a 160-bit node ID. Node IDs are 
currently just random 160-bit identifiers, though they could equally well be 
constructed as in Chord. Every message a node transmits includes its node ID, 
permitting the recipient to record the sender’s existence if necessary.</font></p>
<p><font color="#FF00FF">Keys, too, are 160-bit identifiers. To assign (key,value) 
pairs to particular nodes, Kademlia relies on a notion of distance between two 
identifiers. Given two 160-bit identifiers, x and y, Kademlia defines the 
distance between them as their bitwise exclusive or (XOR) interpreted as an 
integer, d(x,y) = x ® y.</font></p>
<p>This is implemented as:</p>
<pre>public static ID operator ^(ID a, ID b)
{
  byte[] xoredData = new byte[ID_LENGTH];

  for (int i = 0; i &lt; ID_LENGTH; i++)
  {
    xoredData[i] = (byte)(a.data[i] ^ b.data[i]);
  }

  return new ID(xoredData);
}</pre>
<p><font color="#FF00FF">We next note that XOR captures the notion of distance 
implicit in our binary- tree-based sketch of the system. In a fully-populated 
binary tree of 160-bit IDs, the magnitude of the distance between two IDs is the 
height of the smallest subtree containing them both. When a tree is not fully 
populated, the closest leaf to an ID x is the leaf whose ID shares the longest 
common prefix of x. </font></p>
<p>This is handled by the <code>&lt;</code> and <code>&gt;</code> operators used to measure distance:</p>
<pre>public static bool operator &lt;(ID a, ID b)
{
  for (int i = 0; i &lt; ID_LENGTH; i++)
  {
    if (a.data[i] &lt; b.data[i])
    {
      return true; // If first mismatch is a &lt; b, a &lt; b
    }
    else if (a.data[i] &gt; b.data[i])
    {
      return false; // If first mismatch is a &gt; b, a &gt; b
    }
  }

  return false; // No mismatches
}

public static bool operator &gt;(ID a, ID b)
{
  for (int i = 0; i &lt; ID_LENGTH; i++)
  {
    if (a.data[i] &lt; b.data[i])
    {
      return false; // If first mismatch is a &lt; b, a &lt; b
    }
    else if (a.data[i] &gt; b.data[i])
    {
      return true; // If first mismatch is a &gt; b, a &gt; b
    }
  }

  return false; // No mismatches
}</pre>
<p><font color="#FF00FF">If there are empty branches in the tree, there might be more 
than one leaf with the longest common prefix. In that case, the closest leaf to 
x will be the closest leaf to ID x produced by flipping the bits in x 
corresponding to the empty branches of the tree.</font></p>
<p><font color="#FF0000">TODO: Why the randomization?</font></p>
<pre>public ID RandomizeBeyond(int bit)
{
  byte[] randomized = new byte[ID_LENGTH];
  data.CopyTo(randomized, 0);

  FlipBit(randomized, bit); // Invert pivot bit

  // And randomly flip the rest
  for(int i = bit + 1; i &lt; 8 * ID_LENGTH; i++) 
  {
    if(rnd.NextDouble() &lt; 0.5) 
    {
      FlipBit(randomized, i);
    }
  }

  return new ID(randomized);
}

/// &lt;summary&gt;
/// Flips the given bit in the byte array.
/// Byte array must be ID_LENGTH long.
/// &lt;/summary&gt;
/// &lt;param name=&quot;data&quot;&gt;Data to work on&lt;/param&gt;
/// &lt;param name=&quot;bit&quot;&gt;Bit used to generate the mask&lt;/param&gt;
private static void FlipBit(byte[] data, int bit)
{
  int byteIndex = bit / 8;
  int byteBit = bit % 8;
  byte mask = (byte) (1 &lt;&lt; byteBit);

  data[byteIndex] = (byte) (data[byteIndex] ^ mask); // Use a mask to flip the bit
}
</pre>
<h2>Node State (Section 2.2)</h2>
<p><font color="#FF00FF">Kademlia nodes store contact information about each 
other to route query messages. For each 0 &lt; i &lt; 160, every node keeps a list of 
(IP address, UDP port, Node ID) triples for nodes of distance between 2<sup>i</sup> and 
2<sup>i+1</sup> from itself. We call these lists k-buckets. Each k-bucket is kept sorted 
by time last seen—least-recently seen node at the head, most-recently seen at 
the tail. For small values of i, the k-buckets will generally be empty (as no 
appropriate nodes will exist). For large values of i, the lists can grow up to 
size k, where k is a system-wide replication parameter. k is chosen such that 
any given k nodes are very unlikely to fail within an hour of each other (for 
example k = 20).</font></p>
<p>That phrase &quot;fall within an hour of each other&quot; is determined by an analysis 
of the <a href="https://en.wikipedia.org/wiki/Chord_(peer-to-peer)">Chord P2P 
DHT</a>, which can be read in the Kademlia spec.</p>
<h3>Abstracting the Triplet</h3>
<p>The Kademlia spec &quot;hardwires&quot; the contact information as an IP address and 
UDP port.&nbsp; We want to abstract this so that systems that implement other 
addressing schemes can 
be easily implemented.&nbsp; TCP/IP, IPv6, multiple IP addresses for the same 
node, and in-memory node instances for test purposes are some examples of other 
addressing schemes.&nbsp; We'll use an interface and wrapper class for this 
(stubs at the moment):</p>
<pre>public interface IAddress { }

public class Contact
{
  public IAddress Address { get; set; }
  public ID NodeID { get; set; }
}</pre>
<p>The interface IAddress will eventually define methods for handling messages 
that we send.&nbsp; A stub implementation for UDP communication can 
then be defined:</p>
<pre>public class UdpAddress : IAddress
{
  public IPAddress Address { get; set; }
  public int Port { get; set; }
}</pre>
<p>We can also implement a stub for our in-memory testing, which directly 
references the contact node:</p>
<pre>
public class InMemoryNodeAddress : IAddress
{
  public Node RecipientNode { get; set; }
}</pre>
<h3>K-Buckets</h3>
<p>This is where reading the spec starts to feel like those annoying word 
problems in school:</p>
<p><font color="#FF00FF">For each 0 &lt; i &lt; 160, every node keeps a list of 
(IP address, UDP port, Node ID) triples for nodes of distance between 2<sup>i</sup> and 
2<sup>i+1</sup> from itself. We call these lists k-buckets. Each k-bucket is 
kept sorted by time last seen—least-recently seen node at the head, 
most-recently seen at the tail.</font></p>
<p>I believe that the above range for <code>i</code> is wrong: it should be <code>0 &lt;= i &lt; 160</code> as this 
is necessary to allow for a node ID of 0.</p>
<p>Reading the spec on the
<a href="http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html#distance">
SourceForge link</a> makes this a bit clearer:</p>
<p><i>A Kademlia node organizes its contacts, other nodes known to it, in 
buckets which hold a maximum of k contacts. These are known as k-buckets.</i></p>
<p>We can define a couple constants:</p>
<pre>public const int K = 20;
public const int ID_LENGTH_BYTES = 20;
public const int ID_LENGTH_BITS = 160;</pre>
<p>We therefore need to implement a bucket list that contains 160 buckets, each 
with k contacts, and these buckets must be kept sorted (or are sortable) by last 
time seen.&nbsp; The terms &quot;head&quot; and &quot;tail&quot; may not be obvious to people 
anymore (not that such arbitrary terms were ever obvious), so a quick reminder:</p>
<ul>
	<li>The head of the list is the first node (or leftmost node) in the list.</li>
	<li>The tail of the list is the last node (or rightmost node) in the list.</li>
</ul>
<p>Therefore, the contacts in each bucket are kept in oldest-to-newest date/time order -- the 
least recently seen node (the one with the oldest date) at the head (the first entry) and the most recently 
seen (the one with the newest date) at the tail (the last entry.)</p>
<p>Based on this information, we revise our <code>Contact</code> class to include a <code>LastSeen</code> 
property as well as away to update it:</p>
<pre>public class Contact
{
  public DateTime LastSeen { get; set; }
  public IAddress Address { get; set; }
  public ID NodeID { get; set; }

  public void Touch()
  {
    LastSeen = DateTime.Now;
  }
}
</pre>
<p>We define a <code>BucketList</code> class that contains the 160 buckets of k contacts, 
handled in the <code>K_Bucket class</code>:</p>
<pre>public class KBucket
{
  protected List&lt;Contact&gt; contacts;

  public KBucket()
  {
    contacts = new List&lt;Contact&gt;(Constants.K);
  }
}

public class BucketList
{
  protected List&lt;KBucket&gt; buckets;

  public BucketList()
  {
    buckets = new List&lt;KBucket&gt;(Constants.ID_LENGTH_BITS);
    Constants.ID_LENGTH_BITS.ForEach(() =&gt; buckets.Add(new KBucket()));
  }
}</pre>
<p>This creates 3200 <code>Contact</code> entries (160 * 20).&nbsp; We could 
implement this as a <code>List&lt;List&lt;Contact&gt;&gt;</code> but for semantic clarity, I prefer the 
above approach.&nbsp; An overly-cute (but useful) extension method is used:</p>
<pre>public static void ForEach(this int n, Action action)
{
  for (int i = 0; i &lt; n; i++)
  {
    action();
  }
}</pre>
<h3>Adding a Contact</h3>
<p><font color="#FF00FF">Each k-bucket is kept sorted by time last 
seen—least-recently seen node at the head, most-recently seen at the tail.</font></p>
<p>We can implement an <code>HaveContact</code> method whose purpose is to always maintain 
a sorted list.&nbsp; This method does two things:</p>
<ol>
	<li>Adds a contact to the tail if never been seen before, dropping of a 
	contact at the head if the bucket size == k</li>
<li>Moves a contact to the tail if it already exists.</li>
</ol>
<p>This is implemented in the <code>KBucket</code> class and assumes that the correct <code>KBucket</code> 
has been determined already:</p>
<pre>public bool Exists(ID id)
{
  return contacts.Any(c =&gt; c.NodeID == id);
}

public void HaveContact(Contact contact)
{
  if (Exists(contact.NodeID))
  {
    contacts.MoveToTail(contact, c =&gt; c.NodeID == contact.NodeID);
  }
  else
  {
    contacts.AddMaximum(contact, Constants.K);
  }
}</pre>
<p>For readability and to keep the list management separate from the <code>KBucket</code> 
class, these are implemented as extension methods:</p>
<pre>public static void MoveToTail&lt;T&gt;(this List&lt;T&gt; list, T item, Predicate&lt;T&gt; pred)
{
  int idx = list.FindIndex(pred);
  list.RemoveAt(idx);
  list.Add(item);
}

public static void AddMaximum&lt;T&gt;(this List&lt;T&gt; list, T item, int max)
{
  list.Add(item);

  if (list.Count &gt; max)
  {
    list.RemoveAt(0);
  }
}</pre>
<p>Lastly, each node has a bucket list:</p>
<pre>public class Node
{
  public ID NodeID { get; }

  <font color="#FF0000">protected BucketList bucketList;</font>

  public Node()
  {
    NodeID = ID.RandomID();
    <font color="#FF0000">bucketList = new BucketList();</font>
  }
  ...</pre>
<h3>What KBucket Does a Contact go Into?</h3>
<p>Each KBucket represents a range of 2<sup>i</sup> to 2<sup>i+1</sup> nodes, where 0 &lt;= i 
&lt; 160.&nbsp; Given a 160-bit ID, we can determine which k-bucket the contact 
goes into.&nbsp; The k-bucket index is based on powers of 2 which can be 
determined by counting the number of 0 bits from the most significant bit of the 
ID):</p>
<pre>public int GetBucketIndex()
{
  int idx = Constants.ID_LENGTH_BITS - 1;
  int msbyte = 0;
  int msbit = 0x80;
  bool done = false;

  while (msbyte &lt; Constants.ID_LENGTH_BYTES &amp;&amp; !done)
  {
    while (msbit != 0)
    {
      if ((id[msbyte] &amp; msbit) == 0)
      {
        --idx;
        msbit &gt;&gt;= 1;
      }
      else
      {
        done = true;
        break;
      }
    }

    msbit = 0x80;
    ++msbyte;
  }

  return idx + (!done ? 1 : 0); // compensate for last --idx
}</pre>
<p>An ID of 0 should have a bucket index of 0 (representing 2<sup>^0</sup> 
through 2<sup>^1</sup> - 1) and an ID with the most significant&nbsp;set should have 
a bucket index of 159, representing 2<sup>^159</sup> through 2<sup>^160</sup> - 1.&nbsp; 
A simple test:</p>
<pre>ID id1 = new ID(new byte[20]);
int idx1 = id1.GetBucketIndex();
Console.WriteLine(idx1);

byte[] b2 = new byte[20];
b2[0] = 0x80;
ID id2 = new ID(b2);
int idx2 = id2.GetBucketIndex();
Console.WriteLine(idx2);</pre>
<p>
gives us:</p>
<p>
<img border="0" src="bucket1.png" width="219" height="63"></p>
<p>
Or if you prefer a unit test:</p>
<pre>
/// &lt;summary&gt;
/// Test bucket indexing by testing all patterns:
/// 1xxxxx (idx 159)
/// 01xxxx (idx 158)
/// 001xxx (idx 157)
/// etc. that we get the correct index back.
/// &lt;/summary&gt;
[TestMethod]
public void BucketIndexTest()
{
  int byteIdx = 0;
  byte bitIdx = 0x80;

  for (int i = 0; i &lt; Constants.ID_LENGTH_BITS; i++)
  {
    // bits 0 to i are 0, set bit i (counting from MSB), and set remaining bits (of the LSB's) to random values.
    byte[] idbytes = new byte[Constants.ID_LENGTH_BYTES];
    idbytes[byteIdx] = bitIdx;
    ID id = new ID(idbytes);
    id = id.RandomizeBeyond(i);
    int bucketIdx = id.GetBucketIndex();
    Assert.IsTrue(bucketIdx == (Constants.ID_LENGTH_BITS - (i+1)), &quot;Bucket index does not match expected index.&quot;);

    bitIdx &gt;&gt;= 1;

    if (bitIdx == 0)
    {
      ++byteIdx;
      bitIdx = 0x80;
    }
  }
}</pre>
<p>
However!&nbsp; As per the
<a href="http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html#distance">
SourceForge spec</a>: <font color="#FF00FF">The buckets are organized by <b>the 
distance</b> between the node and the contacts in the bucket.</font></p>
<p>
Yes, this is in the Kademlia spec as well, but you have to catch it:</p>
<p>
<font color="#FF00FF">for nodes of <b>distance</b> between 2<sup>i</sup> and 2<sup>i+1</sup> 
<b>from itself</b>.</font> </p>
<p>
(My bolding - the language is the Kademlia spec is more obtuse.)</p>
<p>
Adding a contact to a bucket means that we have to provide <i>our node's ID</i> 
in order to find the correct bucket index.&nbsp; In <code>BucketList</code> we therefore 
implement:</p>
<pre>
public void HaveContact(ID ourId, Contact contact)
{
  var distance = ourId ^ contact.NodeID;
  int bucketIdx = distance.GetBucketIndex();
  buckets[bucketIdx].HaveContact(contact);
}
</pre>
<p>
Now we have the pieces in place for this part of Section 2.2:</p>
<p>
<font color="#FF00FF">When a Kademlia node receives any message (request or 
reply) from another node, it updates the appropriate k-bucket for the sender’s 
node ID. If the sending node already exists in the recipient’s k-bucket, the 
recipient moves it to the tail of the list. If the node is not already in the 
appropriate k-bucket and the bucket has fewer than k entries, then the recipient 
just inserts the new sender at the tail of the list. </font></p>
<p>
But we have a problem with the next part:</p>
<p>
<font color="#FF00FF">If the appropriate k-bucket is full, however, then the 
recipient pings the k-bucket’s least-recently seen node to decide what to do. If 
the least- recently seen node fails to respond, it is evicted from the k-bucket 
and the new sender inserted at the tail. Otherwise, if the least-recently seen 
node responds, it is moved to the tail of the list, and the new sender’s contact 
is discarded.</font></p>
<p>
While we haven't implemented the protocol yet, 
we can refactor the <code>HaveContact</code> method to take a <code>Func</code> 
that we can call to determine what to do (isn't inversion of control awesome?):</p>
<pre>
public void HaveContact(Contact contact, Func&lt;Contact, bool&gt; discardHead)
{
  contact.Touch();

  // If contact exists, promote it to the tail.
  if (Exists(contact.NodeID))
  {
    contacts.MoveToTail(contact, c =&gt; c.NodeID == contact.NodeID);
  }
  else
  {
    // When contact doesn't exist, if there's room to add it, just do so.
    if (contacts.Count &lt; Constants.K)
    {
      contacts.Add(contact);
    }
    else if (discardHead(contacts[0]))
    {
      // Otherwise, if the least recently seen node doesn't respond to a ping, discard it and
      // replace it with our new contact.
      contacts.AddMaximum(contact, Constants.K);
    }
    // Otherwise we discard the new contact, as we don't know anything about how reliable it is.
  }
}</pre>
<p>
and we pass this function in to the <code>BucketList</code> class:</p>
<pre>public void HaveContact(ID ourId, Contact contact, Func&lt;Contact, bool&gt; discardHead)
{
  var distance = ourId ^ contact.NodeID;
  int bucketIdx = distance.GetBucketIndex();
  buckets[bucketIdx].HaveContact(contact, discardHead);
}</pre>
<p>See how nice it is to have separate classes for the bucket list and the 
k-bucket?&nbsp; If we didn't do this, all this code would be in one big ugly 
class.&nbsp; Also, at this point, a unit test verifying that &quot;last seen&quot; 
ordering is preserved is useful:</p>
<pre>/// &lt;summary&gt;
/// Test that contacts added to a kbucket are in least to most-recently seen order.
/// &lt;/summary&gt;
[TestMethod]
public void LeastSeenOrderingTest()
{
  KBucket kbucket = new KBucket();
  40.ForEach(() =&gt;
  {
    kbucket.HaveContact(new Contact(), contact =&gt; false);
    Thread.Sleep(2); // need to have some time go by.
  });

  Assert.IsTrue(kbucket.Contacts.Count == Constants.K, &quot;Expected k contacts.&quot;);

  DateTime last = default(DateTime);
  kbucket.Contacts.ForEach(contact =&gt;
  {
    Assert.IsTrue(last &lt; contact.LastSeen, &quot;Contacts are out of order with regards to last seen.&quot;);
    last = contact.LastSeen;
  });
}</pre>
<p>Granted, this tests only one branch for adding contacts when the bucket is 
full.&nbsp; We can add more tests later.</p>
<p>The whole point of this process is nicely explained in the Kademlia 
documentation:</p>
<p><font color="#FF00FF">k-buckets effectively implement a least-recently seen 
eviction policy, except that live nodes are never removed from the list. This 
preference for old contacts is driven by our analysis of Gnutella trace data 
collected by Saroiu et. al. ... The longer a node has been up, the more likely 
it is to remain up another hour. By keeping the oldest live contacts around, 
k-buckets maximize the probability that the nodes they contain will remain 
online.</font></p>
<p><font color="#FF00FF">A second benefit of k-buckets is that they provide 
resistance to certain DoS attacks. One cannot flush nodes’ routing state by 
flooding the system with new nodes. Kademlia nodes will only insert the new 
nodes in the k-buckets when old nodes leave the system.</font></p>
<p>Pretty cool!</p>
<h2>The Kademlia Protocol (Section 2.3)</h2>
<p>This is where we get into the real meat and potatoes of the spec.&nbsp;
<font color="#FF00FF">The Kademlia protocol consists of four RPCs: PING, 
STORE, FIND_NODE, and FIND_VALUE.&nbsp; </font>Let's explore this a bit before implementing some stubs.</p>
<p><b>Ping</b></p>
<p><font color="#FF00FF">The PING RPC probes a node to see if it is online.</font> </p>
<p>Obviously, a ping will respond with something that we'll call a &quot;pong.&quot;&nbsp; 
We'll deal over-the-wire serialization and responses later (much later.)</p>
<p><b>Store</b></p>
<p><font color="#FF00FF">STORE instructs a node to store a (key, value) pair for 
later retrieval.</font></p>
<p><b>FindNode</b></p>
<p><font color="#FF00FF">FIND_NODE takes a 160-bit ID as an argument. The 
recipient of a the RPC returns (IP address, UDP port, Node ID) triples for the k 
nodes it knows about closest to the target ID. These triples can come from a 
single k-bucket, or they may come from multiple k-buckets if the closest 
k-bucket is not full. In any case, the RPC recipient must return k items (unless 
there are fewer than k nodes in all its k-buckets combined, in which case it 
returns every node it knows about).</font></p>
<p><b>FindValue</b></p>
<p><font color="#FF00FF">FIND_VALUE behaves like FIND_NODE—returning (IP 
address, UDP port, Node ID) triples—with one exception. If the RPC recipient has 
received a STORE RPC for the key, it just returns the stored value.</font></p>
<p>The implication here is that the key associated with the value should be a 
parameter as well.</p>
<p><b>And Lastly</b></p>
<p><font color="#FF00FF">In all RPCs, the recipient must echo a 160-bit random 
RPC ID, which provides some resistance to address forgery, PINGS can also be 
piggy-backed on RPC replies for the RPC recipient to obtain additional assurance 
of the sender’s network address.</font></p>
<p>Both of those statements are a bit confusing, we'll see if we can understand 
it better later.&nbsp; The questions are:</p>
<ul>
	<li>What do we do with this 160-bit random RPC ID and 
	how does it provide resistance to address forgery?</li>
<li><font color="#FF0000">What does that last sentence about piggy-backed pings 
mean?</font></li>
</ul>
<p>Based on the SourceForge spec:</p>
<p><font color="#FF00FF">All RPC packets are required to carry an RPC identifier 
assigned by the sender and echoed in the reply. This is a quasi-random number of 
length B (160 bits).</font></p>
<p>This makes it clearer, as this clearly states what &quot;must echo...&quot; means.&nbsp; 
Again, reading the original spec requires really reading it <i>carefully.</i></p>
<p>We'll also have to deal with this fun statement in the spec:
<font color="#FF00FF">Most operations are implemented in terms of [a] lookup 
procedure.</font></p>
<h3>Stub Implementation</h3>
<p>These are added to the IAddress interface:</p>
<pre>public interface IAddress
{
  Contact Ping(Contact sender, IAddress recipient, ID randomID);
  void Store(Contact sender, IAddress recipient, ID randomID, string key, string val);
  List&lt;Contact&gt; FindNode(Contact sender, IAddress recipient, ID randomID, ID toFind);
  (List&lt;Contact&gt; nodes, string val) FindValue(Contact sender, IAddress recipient, ID randomID, string key);
}</pre>
<p>Note the use of the C# 7 syntax!</p>
<p>Our <code>InMemoryNodeAddress</code> class (and any other communication class) must 
implement these methods, in this case as pass-through's to the node associated 
with the address (the casting bothers me, <font color="#FF0000">something to 
refactor</font>):</p>
<pre>public class InMemoryNodeAddress : IAddress
{
  public Node RecipientNode { get; set; }

  public Contact Ping(Contact sender, IAddress recipient, ID randomID)
  {
    return ((InMemoryNodeAddress)recipient).RecipientNode.Ping(sender);
  }

  public void Store(Contact sender, IAddress recipient, ID randomID, string key, string val)
  {
    ((InMemoryNodeAddress)recipient).RecipientNode.Store(sender, key, val);
  }

  public List&lt;Contact&gt; FindNode(Contact sender, IAddress recipient, ID randomID, ID toFind)
  {
    return ((InMemoryNodeAddress)recipient).RecipientNode.FindNode(sender, toFind);
  }

  public (List&lt;Contact&gt; nodes, string val) FindValue(Contact sender, IAddress recipient, ID randomID, string key)
  {
    return ((InMemoryNodeAddress)recipient).RecipientNode.FindValue(sender, key);
  }
}
</pre>
<p>A few points here:</p>
<ul>
	<li>When communicating over the wire, the parameters must be appropriately 
serialized and the response appropriately deserialized.</li>
	<li>The over-the-wire protocol must be more diligent in verifying the 
	<code>randomID</code> in the response.</li>
	<li>Responders have of course not been implemented yet.</li>
</ul>
<p>Also, it should be obvious that the <code>Node</code> class needs to 
implement these methods as well.&nbsp; Note that the <code>Node</code> class is not directly 
responsible for forming the appropriate packet to serialize and send back to the 
caller -- this will be handled by the responder to the RPC.&nbsp; The <code>Node</code> 
class has been refactored to provide some of this implementation, stubs of 
others.&nbsp; Note the constructor changes as well and the addition of the 
storage <code>property</code>:</p>
<pre>public class Node
{
  public Contact OurContact { get; set; }

  protected BucketList bucketList;
  protected IStorage storage;

  protected Node()
  {
    bucketList = new BucketList();
  }

  public Node(Contact us) : this()
  {
    OurContact = us;
  }

  public Contact Ping(Contact sender)
  {
    return OurContact;
  }

  public void Store(Contact sender, string key, string val)
  {
    storage.Set(key, val);
  }

  public List&lt;Contact&gt; FindNode(Contact sender, ID toFind)
  {
    return null;
  }

  public (List&lt;Contact&gt; nodes, string val) FindValue(Contact sender, string key)
  {
    return (null, null);
  }
}</pre>
<p>Let's revisit this statement:</p>
<p><font color="#FF00FF">When a Kademlia node receives any message (request or 
reply) from another node, it updates the appropriate k-bucket for the sender’s 
node ID.</font></p>
<p>and refactor the Node class <i>yet again</i> to implement this requirement:</p>
<pre>public Contact Ping(Contact sender)
{
  bucketList.HaveContact(OurContact.NodeID, sender, (_) =&gt; false);
  return OurContact;
}

public void Store(Contact sender, string key, string val)
{
  bucketList.HaveContact(OurContact.NodeID, sender, (_) =&gt; false);
  storage.Set(key, val);
}

public List&lt;Contact&gt; FindNode(Contact sender, ID toFind)
{
  bucketList.HaveContact(OurContact.NodeID, sender, (_) =&gt; false);
  return null;
}

public (List&lt;Contact&gt; nodes, string val) FindValue(Contact sender, string key)
{
  bucketList.HaveContact(OurContact.NodeID, sender, (_) =&gt; false);
  return (null, null);
}</pre>
<p>Note that we're stubbing the &quot;discard head&quot; function at the moment.</p>
<h3>FindNode Basic Implementation</h3>
<p>We'll start with this specification and work out the implementation.</p>
<p><font color="#FF00FF">FIND_NODE takes a 160-bit ID as an argument. The 
recipient of the RPC returns (IP address, UDP port, Node ID) triples for the k 
nodes it knows about closest to the target ID. These triples can come from a 
single k-bucket, or they may come from multiple k-buckets if the closest 
k-bucket is not full. In any case, the RPC recipient must return k items (unless 
there are fewer than k nodes in all its k-buckets combined, in which case it 
returns every node it knows about).</font></p>
<p>It's important to also review the notes on
<a href="http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html#FIND_NODE">
SourceForge</a>: </p>
<p><font color="#FF00FF">The recipient of a FIND_NODE should never return a 
triple containing the nodeID of the requestor. If the requestor does receive 
such a triple, it should discard it. A node must never put its own nodeID into a 
bucket as a contact.</font></p>
<p>To restate these requirements:</p>
<ul>
	<li>The recipient should not return a triple containing the requestor's ID.</li>
	<li>A node must never put its own node ID into a bucket as a contact.</li>
</ul>
<p>The reason for this check is that it prevents would could potentially be 
infinite recursion in the node lookup algorithm (discussed later).&nbsp; Let's 
deal with that second point first.&nbsp; </p>
<pre>public void HaveContact(ID ourId, Contact contact, Func&lt;Contact, bool&gt; discardHead)
{
  // A node must never put its own node ID into a bucket as a contact.
  if (ourId != contact.NodeID)
  {
    var distance = ourId ^ contact.NodeID;
    int bucketIdx = distance.GetBucketIndex();
    buckets[bucketIdx].HaveContact(contact, discardHead);
  }
}</pre>
<p>Done!&nbsp; </p>
<p>The implementation is unfortunately a brute force iteration of all the known 
contacts in the bucket list.&nbsp; The first <i>k</i> nodes that are the 
shortest distance to the ID are returned, in ascending (shortest to greatest) 
distance.&nbsp; This algorithm is modified from the <code>ClosestContacts</code> algorithm
<a href="https://github.com/zencoders/sambatyon/blob/master/Kademlia/Kademlia/BucketList.cs">
here</a>, starting on line 208.&nbsp; (To a large extent, it really helps to 
understand the code by matching the code to the specification.)&nbsp; Using Linq, 
we have:</p>
<pre>/// &lt;summary&gt;
/// Algorithm idea from https://github.com/zencoders/sambatyon/blob/master/Kademlia/Kademlia/BucketList.cs, starting on line 208.
/// Brute force distance lookup of all known contacts, sorted by distance, then we take at most k (20) of the closest.
/// &lt;/summary&gt;
/// &lt;param name=&quot;toFind&quot;&gt;The ID for which we want to find close contacts.&lt;/param&gt;
/// &lt;param name=&quot;exclude&quot;&gt;The ID to exclude (the requestor's ID)&lt;/param&gt;
public List&lt;Contact&gt; GetCloseContacts(ID toFind, ID exclude)
{
  var contacts = buckets.
    SelectMany(b =&gt; b.Contacts).
    Where(c =&gt; c.NodeID != exclude).
    Select(c =&gt; new { contact = c, distance = c.NodeID ^ toFind }).
    OrderBy(d =&gt; d.distance).
    Take(Constants.K);

  return contacts.Select(c=&gt;c.contact).ToList();
}</pre>
<p>Linq is amazing!&nbsp; Note that the <code>where</code> clause takes care of the other 
requirement &quot;The recipient should not return a triple containing the requestor's 
ID.&quot;</p>
<p>This code is ripe for a unit test that verifies the contacts are sorted from 
least to greatest distance:</p>
<pre>// Create k contacts of random ID's and verify that they come back in sorted distances from least distance to greatest.
// We assume that we will never get two occurrances of the same random ID.
[TestMethod]
public void CloseContactTest()
{
  ID ourID = ID.RandomID();
  ID toFind = ID.RandomID();
  BucketList bucketList = new BucketList();
  Constants.K.ForEach(() =&gt; bucketList.HaveContact(ourID, new Contact() { NodeID = ID.RandomID() }, (contact) =&gt; false));
  List&lt;Contact&gt; contacts = bucketList.GetCloseContacts(toFind, ourID);

  Assert.IsTrue(contacts.Count == Constants.K, &quot;Expected k contacts returned.&quot;);

  ID distance = contacts[0].NodeID ^ toFind;

  for (int n = 1; n &lt; Constants.K; n++)
  {
    ID nextDistance = contacts[n].NodeID ^ toFind;
    Assert.IsTrue(distance &lt; nextDistance, &quot;Distances are not sorted in least to greatest order.&quot;);
    distance = nextDistance;
  }
}</pre>
<p>One might think that once the initial bucket index is found, one 
should be able to find &quot;nearby buckets&quot; by expanding the search to neighboring 
buckets +/- <i>n</i>, incrementing n until<i> k</i> contacts are found or we've 
searched the entire bucket list.&nbsp; It looks like this is what
<a href="https://github.com/bmuller">Brian Muller</a> implemented in the 
TableTraverser class in his Python version:</p>
<pre>def next(self):
  &quot;&quot;&quot;
  Pop an item from the left subtree, then right, then left, etc.
  &quot;&quot;&quot;
  if len(self.currentNodes) &gt; 0:
    return self.currentNodes.pop()

  if self.left and len(self.leftBuckets) &gt; 0:
    self.currentNodes = self.leftBuckets.pop().getNodes()
    self.left = False
    return self.next()

  if len(self.rightBuckets) &gt; 0:
    self.currentNodes = self.rightBuckets.pop().getNodes()
    self.left = True
    return self.next()

  raise StopIteration</pre>
<p>However, as Brian himself points out in
<a href="https://github.com/bmuller/kademlia/issues/28">an issue</a>, and as
<a href="https://stackoverflow.com/questions/30654398/implementing-find-node-on-torrent-kademlia-routing-table">
this Stack Overflow response</a> states: &quot;Since the XOR distance metric folds at 
each bit-carry (XOR == carry-less addition) it does not map nicely to any 
routing table layout. In other words, visiting the nearest buckets won't do.&quot;&nbsp; 
So we'll stick with the brute force algorithm.</p>
<h3>Node Lookup Implementation</h3>
<p>Now we get to the business of &quot;<font color="#FF00FF">Most operations are 
implemented in terms of [a] lookup procedure.</font>&quot;&nbsp; The lookup procedure 
in the spec is described as (my numbering):</p>
<ol>
	<li><font color="#FF00FF">Kademlia employs a recursive algorithm for node 
	lookups. The lookup initiator starts by picking alpha nodes from its closest 
	non-empty k-bucket (or, if that bucket has fewer than a entries, it just 
	takes the alpha closest nodes it knows of).</font></li>
	<li><font color="#FF00FF">The initiator then sends parallel, asynchronous 
	FIND_NODE RPCS to the alpha nodes it has chosen, alpha is a system-wide concurrency 
	parameter, such as 3.</font></li>
	<li><font color="#FF00FF">In the recursive step, the initiator resends the 
	FIND_NODE to nodes it has learned about from previous RPCs. (This recursion 
	can begin before all a of the previous RPCs have returned). </font></li>
	<li><font color="#FF00FF">Of the k nodes the initiator has heard of closest 
	to the target, it picks alpha that it has not yet queried and resends the FIND_NODE RPC to them. </font></li>
	<li><font color="#FF00FF">Nodes that fail to respond quickly are removed 
	from consideration until and unless they do respond. </font></li>
	<li><font color="#FF00FF">If a round of FIND_NODES fails to return a node 
	any closer than the closest already seen, the initiator resends the 
	FIND_NODE to all of the k closest nodes it has not already queried. </font>
	</li>
	<li><font color="#FF00FF">The lookup terminates when the initiator has 
	queried and gotten responses from the k closest nodes it has seen.</font></li>
</ol>
<p>There are some questions points to this set of requirements:</p>
<ol>
	<li>What is this &quot;recursive&quot; thing?&nbsp; The SourceForge spec says that the 
	algorithm is actually iterative.</li>
	<li>I'm going to assume that while the node lookup algorithm uses 
	the <code>FindNode</code> RPC, it is not recursive -- <code>FindNode</code> itself does not initiate 
	its own node lookup algorithm.&nbsp; Both
	<a href="https://github.com/bmuller/kademlia">Brian's Python code</a> and 
	the <a href="https://github.com/zencoders/sambatyon/tree/master/Kademlia">C# 
	zencoders</a> implementation confirm this: <code>FindNode</code> simply returns the 
	closest nodes known to the recipient. </li>
<li>Do operations like <code>Store</code> and <code>GetValue</code> use this algorithm?&nbsp; In the 
Python code, no -- the node lookup algorithm is implemented in completely 
separate
<a href="https://github.com/bmuller/kademlia/blob/master/kademlia/crawling.py">
<code>NodeSpiderCrawl</code> and <code>ValueSpiderCrawl</code> classes</a>.&nbsp; The node lookup is 
	not called as part of the <code>Store</code>, <code>FindNode</code>, or <code>FindValue</code> calls -- only 
	immediate neighbors are returned for <code>FindNode</code> and <code>FindValue</code>.&nbsp; 
	Conversely, in the C# zencoders algorithm, the answer is yes -- <code>Store</code> calls <code>
	IList&lt;Contact&gt; closest = IterativeFindNode(ID.FromString(tag.Hash));</code> 
which is the node lookup algorithm.</li>
	<li>It makes sense for FindValue to call the node lookup algorithm, and 
	again, in the C# zencoders implementation, we see this in the call 
	<code>IterativeFindValue(key, ref found, out close);</code></li>
</ol>
<p>With regards to node lookup, it appears that the main difference between 
Brian's Python code and zencoders C# code is that in the Python code, the 
discovery of closer nodes is handled by a separate crawler.&nbsp; I can see pros 
and cons to this implementation, particularly in the performance of the <code>Store</code> 
and <code>FindValue</code> RPC calls, but it's a tradeoff between performance and accuracy (finding the nearest node.)</p>
<p>A few other points:</p>
<ul>
	<li>Statements like &quot;nodes that fail to respond quickly&quot; always bother me -- 
	any time dependent aspect of an algorithm is suspect.&nbsp;&nbsp; </li>
	<li>This algorithm clearly demands an asynchronous implementation.&nbsp; 
	This makes it harder to test, which we'll attempt to deal with later.</li>
</ul>
<p>It's worth comparing the original spec with the SourceForge writeup.&nbsp; 
The algorithm is the same, but reading it expressed in a different way is 
useful, particularly to disambiguate the meaning of phrases like &quot;it has learned 
about from previous RPC's&quot; in the original spec.&nbsp; Does this many nodes 
discovered in the lookup algorithm, or any node from any previous RPC?&nbsp; It 
appears that &quot;nodes discovered in the lookup algorithm&quot; is the meaning of 
&quot;previous RPC's.&quot;</p>
<ol>
	<li><font color="#FF00FF">The search begins by selecting alpha contacts from 
	the non-empty k-bucket closest to the bucket appropriate to the key being 
	searched on. If there are fewer than alpha contacts in that bucket, contacts 
	are selected from other buckets. The contact closest to the target key, 
	closestNode, is noted.</font></li>
	<li><font color="#FF00FF">The first alpha contacts selected are used to 
	create a shortlist for the search.</font></li>
	<li><font color="#FF00FF">The node then sends parallel, asynchronous FIND_* 
	RPCs to the alpha contacts in the shortlist. Each contact, if it is live, 
	should normally return k triples. If any of the alpha contacts fails to 
	reply, it is removed from the shortlist, at least temporarily.</font></li>
	<li><font color="#FF00FF">The node then fills the shortlist with contacts 
	from the replies received. These are those closest to the target. From the 
	shortlist it selects another alpha contacts. The only condition for this 
	selection is that they have not already been contacted. Once again a FIND_* 
	RPC is sent to each in parallel.</font></li>
	<li><font color="#FF00FF">Each such parallel search updates closestNode, the 
	closest node seen so far.</font></li>
	<li><font color="#FF00FF">The sequence of parallel searches is continued 
	until either no node in the sets returned is closer than the closest node 
	already seen or the initiating node has accumulated k probed and known to be 
	active contacts.</font></li>
	<li><font color="#FF00FF">If a cycle doesn't find a closer node, if 
	closestNode is unchanged, then the initiating node sends a FIND_* RPC to 
	each of the k closest nodes that it has not already queried.</font></li>
	<li><font color="#FF00FF">At the end of this process, the node will have 
	accumulated a set of k active contacts or (if the RPC was FIND_VALUE) may 
	have found a data value. Either a set of triples or the value is returned to 
	the caller.</font></li>
</ol>
<h4>Unit Test</h4>
<p>Writing a unit test for this is an interesting exercise in testing the 
algorithm in a controlled manner.&nbsp; We can start with a node that has a 
bucket list with <i>k</i> nodes, but only the first node knows about the other 
nodes.&nbsp; We also want to control the ID's so that the test results are 100% 
reproducible and in such a way that the distance metric is easily worked with.&nbsp; 
For that, we'll create nodes (up to 159) where the node id is 2<sup>^nodeNum</sup>:
</p>
<pre>/// &lt;summary&gt;
/// Create nodes with known ID's from 1 to 2^n
/// &lt;/summary&gt;
private List&lt;Node&gt; CreateNodes(int n)
{
  List&lt;Node&gt; nodes = new List&lt;Node&gt;();
  ID id = ID.OneID();
  Node node;

  n.ForEach(() =&gt;
  {
    var address = new InMemoryNodeAddress();
    nodes.Add(node = new Node(address, id));
    address.RecipientNode = node;
    id &lt;&lt;= 1;
  });

  return nodes;
}</pre>
<p>Now we can write a simple test in which 20 nodes are created, but only the 
first node knows of the remaining 19.&nbsp; This helps us test the case where 
the closer contacts return nothing, so all the work is being done by the 
<code>NodeLookup</code> method, and while the <code>LookupCloserContacts</code> method is called, it does 
nothing.&nbsp; This test verifies that the first node returned is indeed the 
closest non-self node to ID 0 and ID(max).&nbsp; Because there's nothing to do, 
the resulting contact list has only alpha nodes.</p>
<pre>[TestMethod]
public void SimpleOneNodeTest()
{
  // Create k nodes and register nodes 1 through k-1 onto node 0.
  List&lt;Node&gt; nodes = CreateNodes(Constants.K);
  nodes.Skip(1).ForEach(n =&gt; nodes[0].SimpleRegistration(n.OurContact));
  Router router = new Router();
  List&lt;Contact&gt; contacts;

  contacts = router.NodeLookup(ID.ZeroID(), nodes[0]);
  Assert.IsTrue(contacts.Count == 3, &quot;Expected alpha items&quot;);
  // Don't forget, we exclude ourselves!
  Assert.IsTrue(contacts[0] == nodes[1].OurContact, &quot;Expected contact 0 to be returned.&quot;);

  contacts = router.NodeLookup(ID.MaxID(), nodes[0]);
  Assert.IsTrue(contacts.Count == 3, &quot;Expected alpha items&quot;);
  Assert.IsTrue(contacts[0] == nodes[19].OurContact, &quot;Expected contact 0 to be returned.&quot;);
}</pre>
<p>Next, we'd like to create a test that forces the maximum number of traversals 
-- every node returns a closer contact.&nbsp; We can set this up as a linear 
(that is, not circular) chain:</p>
<ul>
	<li>node 0 knows only about node 1</li>
	<li>node 1 knows about node 0 and node 2</li>
	<li>node 2 knows about node 1 and node 3</li>
	<li>etc.</li>
	<li>node 19 knows only about node 18</li>
</ul>
<p>Therefore, if we ask node 0 for ID(max), it must traverse to node 19 to find 
that closest node.&nbsp; If we ask node 19 for ID(0), it must traverse to node 0 
to find the closest match.&nbsp; Note how we get a list of <i>k</i> visited 
nodes.</p>
<p>Next, we can circularize the list to test that the routine exits when the no 
nodes closer can the current one exists.&nbsp; Note how we get a list of alpha 
visited nodes.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Asynchronous Behavior</h2>
<p>So far, I haven't dealt at all with the issue of simultaneous RPC calls nor 
performance improvements, particularly in the node lookup algorithm, that can be 
achieved by processes responses as soon as they come in.&nbsp; The
<a href="https://github.com/zencoders/sambatyon/tree/master/Kademlia">C# 
zencoders</a> implementation is very nicely asynchronous, particularly with 
regards to the node lookup algorithm.&nbsp; </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>
<font color="#FF00FF">To locate nodes near a particular ID, Kademlia uses a single routing algorithm 
from start to finish. </font></p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>

</html>